var async = require('async');
var fs = require('fs');
var _ = require('underscore');
var coa = require('coa');

_.mixin({
    /*
     * Return an object representing the specified array, indexed by the specified key
     * 
     * For example:
     * _.indexArray([
     *     { name: 'one', value: 1 },
     *     { name: 'two', value: 2 },
     *     { name: 'three', value: 3 }
     * ], 'name');
     * 
     * Would return:
     * {
     *     one: { name: 'one', value: 1 },
     *     two: { name: 'two', value: 2 },
     *     three: { name: 'three', value: 3 }
     * }
     */
    indexArray: function(array, key) {
        var indexed = {};
        array.forEach(function(element) {
            indexed[element[key]] = element;
        });
        return indexed;
    }
});

coa.Opt = require('coa/lib/opt.js').Opt;
coa.Arg = require('coa/lib/arg.js').Arg;

/**
 * Apply the properties from the specified object to this command, option, or argument
 * 
 * For example:
 * cmd.applyObject({
 *     name: 'command',
 *     title: 'An awesome command'
 * });
 * 
 * Is equivalent to:
 * cmd.name('command').title('An awesome command');
 */
var applyObject = function(coaObject, specialProperties) {
    if (!coaObject) {
        // Do nothing if this is a null or undefined object
        return this;
    }
    
    var self = this;
    _.each(coaObject, function(value, key) {
        if (specialProperties && specialProperties[key]) {
            // Allow the caller to specify special behavior for this property
            specialProperties[key](value);
        }
        else {
            // Directly call a function on the object
            self[key](value);
        }
    });
    return self;
};
coa.Opt.prototype.applyObject = coa.Arg.prototype.applyObject = applyObject;
coa.Cmd.prototype.applyObject = function(coaObject) {
    var self = this;
    
    if (!self.command || !self.command.module.COA) {
        // This is not a special command (one loaded through
        // loadCommands), so use the simple version of applyObject
        return applyObject.apply(this, arguments);
    }
    
    // Augment the command's option and argument definitions and
    // inherited options or arguments with those of the command's parent
    var inherited = [];
    var parent = self._cmd;
    var COA = self.command.module.COA;
    var parentCOA = parent.command ? parent.command.module.COA : null;
    if (parent !== self && parentCOA) {
        inherited = parentCOA.inherited;
    }
    // Index these arrays by the name of the option or argument
    var indexedOpts = _.indexArray(COA.definitions.opts, 'name');
    var indexedArgs = _.indexArray(COA.definitions.args, 'name');
    
    // Now apply the inherited options and arguments to this command
    inherited.forEach(function(name) {
        var opt = indexedOpts[name];
        var arg = indexedArgs[name];
        if (opt) {
            self.opt().applyObject(opt).end();
        }
        else if (arg) {
            self.arg().applyObject(arg).end();
        }
        else {
            console.error('The inherited parameter "%s" does not match any defined option or argument!'.error, name.info);
        }
    });
    
    return applyObject.call(this, coaObject, {
        // These properties are handled specially
        opts: function(opts) {
            opts.forEach(function(optName) {
                self.opt().applyObject(indexedOpts[optName]).end();
            });
        },
        args: function(args) {
            args.forEach(function(argName) {
                self.arg().applyObject(indexedArgs[argName]).end();
            });
        },
        // These properties should be ignored
        definitions: _.identity,
        inherited: _.identity,
        operations: _.identity
    });
};

var rootCommand = module.exports.rootCommand = coa.Cmd();

var path = require('path');
coa.Cmd.prototype.loadCommands = function(options) {
    // Set option defaults
    _.defaults(options, {
        setupStack: []
    });
    
    var cmd = this;
    var parent = cmd;
    
    var commandsDir = path.join(options.rootDirectory, 'commands');
    var files = fs.readdirSync(commandsDir);
    var commands = cmd.commands = files.map(function(command) {
        var commandPath = path.join(commandsDir, command);
        var commandModule = commandPath;
        
        var stat = fs.statSync(commandPath);
        var isDirectory = stat.isDirectory();
        if (isDirectory) {
            // This command is a package (e.g. directory), rather than
            // a simple file, so the command definition module is
            // the command.js file inside the command directory
            commandModule = path.join(commandPath, 'command.js');
        }
        
        return {
            name: command,
            path: commandPath,
            module: commandModule,
            package: isDirectory
        };
    });
    
    // Load each of the commands
    commands.forEach(function(command) {
        // Load the command from the external module
        var module = command.module = require(command.module);
        _.defaults(module, {
            COA: {}
        });
        
        try {
            // Attempt to initialize the command module
            // This may throw a MODULE_NOT_FOUND exception if the command's npm dependencies have not been installed
            if (module.load) {
                module.load();
            }
        }
        catch(e) {
            if (e.code === 'MODULE_NOT_FOUND') {
                // The command dependencies have probably not been installed properly
                console.error('Failed to load command "%s"!'.error, command.name);
                console.error('Try running "appdev install" to install command npm dependencies'.hint);
            }
            else {
                throw e; // rethrow exception
            }
        }
        
        // Set default properties for the COA object
        var COA = module.COA;
        _.defaults(COA, {
            name: command.name,
            helpful: true,
            opts: [],
            args: [],
            definitions: {},
            inherited: [],
            operations: {}
        });
        _.defaults(COA.definitions, {
            opts: [],
            args: []
        });
        
        var subcmd = command.cmd = cmd.cmd();
        subcmd.command = command;
        
        if (options.coaPreProcess) {
            // Facilitate generic pre-processing of commands
            subcmd.apply(options.coaPreProcess);
        }
        
        if (parent.command) {
            // Augment the command's option and argument definitions, inherited
            // options or arguments, and operations with those of the command's parent
            var parentCOA = parent.command.module.COA;
            COA.definitions.opts = parentCOA.definitions.opts.concat(COA.definitions.opts);
            COA.definitions.args = parentCOA.definitions.args.concat(COA.definitions.args);
            COA.inherited = parentCOA.inherited.concat(COA.inherited);
            _.extend(COA.operations, parentCOA.operations);
        }
        
        if (module.operationStack) {
            var operationStack = options.setupStack.concat(module.operationStack).map(function(operation) {
                return (typeof operation === 'function') ? operation : COA.operations[operation];
            });
            operationStack.forEach(function(operation) {
                _.defaults(operation, {
                    flag: null,
                    negated: false,
                    processed: false,
                    opts: []
                });
                if (!operation.processed && operation.flag) {
                    // Remember that this operation has already been processed
                    operation.processed = true;
                    
                    if (operation.flag[0] === '!') {
                        // Strip off the preceding exclamation point and negate the flag
                        operation.negated = true;
                        operation.flag = operation.flag.slice(1);
                    }
                    // This flag is needed by the command
                    operation.opts.push(operation.flag);
                }
                COA.opts = COA.opts.concat(operation.opts);
            });
            subcmd.act(function(opts, args, res) {
                var params = _.extend({
                    command: this._name // the name of the command being executed
                }, opts, args);
                
                // Filter out operations based on the command-line flags present
                var operations = operationStack.filter(function(operation) {
                    if (operation.flag) {
                        // If the flag name is negated (preceeded by an exclamation point),
                        // the operation should be filtered out only if the flag IS present
                        return operation.negated ? !params[operation.flag] : params[operation.flag];
                    }
                    else {
                        // This operation has no flag and is always enabled
                        return true;
                    }
                }).map(function(operation) {
                    return async.apply(operation, params);
                });
                return require('q').nfcall(async.series, operations).then(function() {
                    // Suppress output
                    return null;
                });
            });
        }
        if (typeof COA === 'function') {
            // Run it in the context of this command
            subcmd.apply(COA);
        }
        // Now apply the object's properties to the command
        subcmd.applyObject(COA);
        
        if (options.coaPostProcess) {
            // Facilitate generic post-processing of commands
            subcmd.apply(options.coaPostProcess);
        }
        subcmd.end();
    });
    
    // Add the install command to install command dependencies
    cmd.cmd() // inplace subcommand definition
        .name('install').title('Install command npm dependencies').helpful()
        .act(function() {
            var npm = require('npm');
            npm.load({}, function(err) {
                if (err) throw err;
                
                var install = function(command, callback) {
                    if (command.package) {
                        // Install this command's npm depdendencies if it is a package and not a single-file command
                        console.log('install'.green, command.name.info);
                        async.series([
                            function(callback) {
                                npm.localPrefix = command.path;
                                npm.commands.update([], callback);
                            },
                            function(callback) {
                                var subcommands = command.cmd.commands;
                                if (subcommands) {
                                    // Recursively install the command's subcommands
                                    async.eachSeries(subcommands, install, callback);
                                }
                                else {
                                    callback(null);
                                }
                            }
                        ], callback);
                    }
                    else {
                        callback(null);
                    }
                };
                
                async.eachSeries(commands, install, function(err) {
                    if (err) throw err;
                });
            });
            // Echo npm output to the console
            npm.on('log', function(message) {
                console.log(message);
            });
        })
        .end(); // end subcommand definition
    
    return this;
};
