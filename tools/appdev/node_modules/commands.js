var async = require('async');
var fs = require('fs');
var _ = require('underscore');
var coa = require('coa');

coa.Opt = require('coa/lib/opt.js').Opt;
coa.Arg = require('coa/lib/arg.js').Arg;

// Return an array of the parent commands of this object
coa.Cmd.prototype.getParents = coa.Opt.prototype.getParents = coa.Arg.prototype.getParents = function() {
    var parents = [];
    var _cmd = this;
    while (_cmd !== _cmd._cmd) {
        _cmd = _cmd._cmd;
        parents.push(_cmd);
    }
    return parents.reverse();
};

/**
 * Apply the properties from the specified object to this command, option, or argument
 * 
 * For example:
 * cmd.applyObject({
 *     name: 'command',
 *     title: 'An awesome command'
 * });
 * 
 * Is equivalent to:
 * cmd.name('command').title('An awesome command');
 */
coa.Cmd.prototype.applyObject = coa.Opt.prototype.applyObject = coa.Arg.prototype.applyObject = function(coaObject) {
    if (!coaObject) {
        // Do nothing if this is a null or undefined object
        return this;
    }
    
    var self = this;
    
    // Conglomerate the option and argument definitions from all of the command's parents
    var parents = self.getParents();
    var optsDefinitions = {};
    var argsDefinitions = {};
    var inherited = [];
    parents.forEach(function(parent) {
        if (parent.command) {
            var COA = parent.command.module.COA;
            COA.definitions.opts.forEach(function(opt) {
                optsDefinitions[opt.name] = opt;
            });
            COA.definitions.args.forEach(function(arg) {
                argsDefinitions[arg.name] = arg;
            });
            inherited = inherited.concat(COA.inherited);
        }
    });
    
    if (self instanceof coa.Cmd) {
        // Now apply inherited options and arguments to this command
        inherited.forEach(function(name) {
            var opt = optsDefinitions[name];
            var arg = argsDefinitions[name];
            if (opt) {
                self.opt().applyObject(opt).end();
            }
            else if (arg) {
                self.arg().applyObject(arg).end();
            }
            else {
                console.error('The inherited parameter "%s" does not match any defined option or argument!'.error, name.info);
            }
        });
    }
    
    var ignoredKeys = ['definitions', 'inherited'];
    _.each(coaObject, function(value, key) {
        if (key === 'opts') {
            value.forEach(function(opt) {
                self.opt().applyObject((typeof opt === 'string') ? optsDefinitions[opt] : opt).end();
            });
        }
        else if (key === 'args') {
            value.forEach(function(arg) {
                self.arg().applyObject((typeof arg === 'string') ? argsDefinitions[arg] : arg).end();
            });
        }
        else if (ignoredKeys.indexOf(key) === -1) {
            // This is not an ignored key, so directly call a function on the object
            self[key](value);
        }
    });
    return self;
};

var rootCommand = module.exports.rootCommand = coa.Cmd();

var path = require('path');
coa.Cmd.prototype.loadCommands = function(options) {
    // Set option defaults
    _.defaults(options, {
        setupStack: []
    });
    
    var cmd = this;
    
    var commandsDir = path.join(options.rootDirectory, 'commands');
    var files = fs.readdirSync(commandsDir);
    var commands = cmd.commands = files.map(function(command) {
        var commandPath = path.join(commandsDir, command);
        var commandModule = commandPath;
        
        var stat = fs.statSync(commandPath);
        var isDirectory = stat.isDirectory();
        if (isDirectory) {
            // This command is a package (e.g. directory), rather than
            // a simple file, so the command definition module is
            // the command.js file inside the command directory
            commandModule = path.join(commandPath, 'command.js');
        }
        
        return {
            name: command,
            path: commandPath,
            module: commandModule,
            package: isDirectory
        };
    });
    
    // Load each of the commands
    commands.forEach(function(command) {
        // Load the command from the external module
        var module = command.module = require(command.module);
        
        try {
            var subcmd = command.cmd = cmd.cmd();
            subcmd.command = command;
            
            // Initialize the command module
            if (module.load) {
                module.load();
            }
            
            if (options.coaPreProcess) {
                // Facilitate generic pre-processing of commands
                subcmd.apply(options.coaPreProcess);
            }
            
            // Now add the command as a coa subcommand if it loaded successfully
            subcmd.name(command.name);
            var COA = module.COA;
            _.defaults(COA, {
                helpful: true,
                definitions: {},
                inherited: []
            });
            _.defaults(COA.definitions, {
                opts: [],
                args: []
            });
            if (typeof COA === 'function') {
                // Run it in the context of this command
                subcmd.apply(COA);
            }
            // Now apply the object's properties to the command
            subcmd.applyObject(COA);
            
            if (module.operationStack) {
                var operationStack = options.setupStack.concat(module.operationStack);
                subcmd.act(function(opts, args, res) {
                    var params = _.extend({
                        command: this._name // the name of the command being executed
                    }, opts, args);
                    
                    // Filter out operations based on the command-line flags present
                    var operations = operationStack.filter(function(operation) {
                        var flag = operation.flag;
                        if (flag) {
                            // If the flag name is preceeded by an exlamation point (!), the
                            // operation should be filtered out only if the flag IS present
                            return (flag[0] === '!') ? !params[flag.slice(1)] : params[flag];
                        }
                        else {
                            // This operation has no flag and is always enabled
                            return true;
                        }
                    }).map(function(operation) {
                        return async.apply(operation, params);
                    });
                    return require('q').nfcall(async.series, operations).then(function() {
                        // Suppress output
                        return null;
                    });
                });
            }
            
            if (options.coaPostProcess) {
                // Facilitate generic post-processing of commands
                subcmd.apply(options.coaPostProcess);
            }
            subcmd.end();
        }
        catch(e) {
            if (e.code === 'MODULE_NOT_FOUND') {
                // The command dependencies have probably not been installed properly
                console.error('Failed to load command "%s"!'.error, command.name);
                console.error('Try running "appdev install" to install command npm dependencies'.hint);
            }
            else {
                throw e; // rethrow exception
            }
        }
    });
    
    // Add the install command to install command dependencies
    cmd.cmd() // inplace subcommand definition
        .name('install').title('Install command npm dependencies').helpful()
        .act(function() {
            var npm = require('npm');
            npm.load({}, function(err) {
                if (err) throw err;
                
                var install = function(command, callback) {
                    if (command.package) {
                        // Install this command's npm depdendencies if it is a package and not a single-file command
                        console.log('install'.green, command.name.info);
                        async.series([
                            function(callback) {
                                npm.localPrefix = command.path;
                                npm.commands.update([], callback);
                            },
                            function(callback) {
                                var subcommands = command.cmd.commands;
                                if (subcommands) {
                                    // Recursively install the command's subcommands
                                    async.eachSeries(subcommands, install, callback);
                                }
                                else {
                                    callback(null);
                                }
                            }
                        ], callback);
                    }
                    else {
                        callback(null);
                    }
                };
                
                async.eachSeries(commands, install, function(err) {
                    if (err) throw err;
                });
            });
            // Echo npm output to the console
            npm.on('log', function(message) {
                console.log(message);
            });
        })
        .end(); // end subcommand definition
    
    return this;
};
